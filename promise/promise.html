<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
  var MyPromise = (function(factory, gobal) {
       return factory.call(gobal);
   })(function() {
       let status = {
           pending: 0,
           fulfilled: 1, // 成功
           reject: 2 // 失败
       };
       class MyPromise {
           // func是promise的参数，参数是一个方法，里面有resolve reject两个参数
           constructor(func) {
               // 初始状态
               this._status = status.pending;
               // 收集成功状态要执行的函数
               this.resolveResult = [];
               // 收集失败状态要执行的函数
               this.rejectResult = [];

               // 记录resolve函数的参数
               this._value = null;

               // 记录reject函数的参数
               this._error = null;
               this._handler(func);
           }
           // 接收外部传入的函数，同时调用外部传入的函数的
           _handler(func) {
            let done = false; // 就是让函数只执行一次
            func((value)=> { // resolve
                if(done) return;
                done = true;
                this._resolve(value);
            },
            (error)=> { // reject
                if(done) return;
                done = true;
                this._reject(error);
            }
            );
           }
           _resolve(value) {
               setTimeout(() => {
                   // 将状态改为成功
                this._status = status.fulfilled; // 1
                this._value = value;

                // 执行所有成功的函数
                this.resolveResult.forEach(callback=> {
                    callback(this._value);
                });
               });
               
           }
           _reject(error) {
               setTimeout(()=> {
                this._status = status.reject; // 2
                this._error = error;

                // 执行所有成功的函数
                this.rejectResult.forEach(callback=> {
                    callback(this._error);
                });
               })
               
           }
           
           // 收集注册的成功状态或失败状态要执行的函数
           _done(resolveFun, rejectFun) {
               // pending 的时候收集
               resolveFun = typeof resolveFun === 'function' ? resolveFun : null;
               rejectFun = typeof rejectFun === 'function' ? rejectFun : null;
               if (this._status === 0) {
                resolveFun && this.resolveResult.push(resolveFun);
                rejectFun &&  this.rejectResult.push(rejectFun);
                // 直接执行 (在 new Promise时不立即执行then方法，
                // 而是在一个特定的环境下去执行then方法，如在一个点击事件下去执行then方法，这个时候resolve已经执行完毕，状态就为1了，就直接执行then方法中的resolve函数)
               } else if (this._status === 1) { 
                console.log('------直接执行--------');
                resolveFun && resolveFun(this._value);
               } else if (this._status === 2) {
                rejectFun && rejectFun(this._error);
               }
           }

           
           then(resolveFun, rejectFun) {
               this._done(resolveFun, rejectFun);
           }
       }
       return MyPromise;
    }, this);








    const p = new MyPromise((resolve)=> {
        // setTimeout(()=> {
            console.log(1);
            resolve('测试resolve');
        // }, 3000);
    });

    p.then((data)=> {
        console.log(2);
        console.log('第一个then成功', data);
    }, (error)=> {
        console.log('第一个then的失败', error);
    });
    console.log(3);



    const p1 = new Promise((resolve)=> {
        console.log(1111);
        resolve();
    })

    p1.then(()=> {
        console.log(22222);
    })
    
    console.log(3333);





</script>
</html>